name: Build Electron Apps

on:
  push:
    branches: [main, dev]
    tags: ["v*"]
  workflow_dispatch:
    inputs:
      tag:
        description: "Tag to build (e.g., v1.2.0)"
        required: false
      branch:
        description: "Branch to build (main or dev)"
        required: false
        default: "main"

jobs:
  build:
    runs-on: ${{ matrix.os }}
    permissions:
      contents: write
    strategy:
      matrix:
        os: [macos-latest, windows-latest]

    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 16

      # For Windows, we might need to set build configuration first
      - name: Configure build environment (Windows only)
        if: matrix.os == 'windows-latest'
        run: |
          npm config set msvs_version 2019
        shell: bash

      # Install all dependencies from package.json
      - name: Install dependencies
        run: npm ci

      # Build the app
      - name: Build Electron app
        run: |
          if [ "${{ matrix.os }}" == "macos-latest" ]; then
            CSC_IDENTITY_AUTO_DISCOVERY=false npm run build:mac
          elif [ "${{ matrix.os }}" == "windows-latest" ]; then
            CSC_IDENTITY_AUTO_DISCOVERY=false npm run build:win
          fi
        shell: bash
        env:
          GH_TOKEN: ${{ secrets.PACKAGES }}

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.os }}-artifacts
          path: |
            dist/*.exe
            dist/*.dmg
            dist/*.zip

  release:
    needs: build
    if: startsWith(github.ref, 'refs/tags/v') || github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout code for release notes
        uses: actions/checkout@v4

      - name: Extract version from tag
        id: extract-version
        run: |
          if [[ "${{ github.ref }}" == refs/tags/* ]]; then
            TAG="${GITHUB_REF#refs/tags/}"
            VERSION="${TAG#v}"
            echo "VERSION=$VERSION" >> $GITHUB_ENV
            echo "TAG=$TAG" >> $GITHUB_ENV
            echo "Using version $VERSION from tag $TAG"
          else
            echo "Not a tag push, using 'latest'"
            echo "TAG=latest" >> $GITHUB_ENV
          fi

      - name: Extract release notes from CHANGELOG.md
        if: startsWith(github.ref, 'refs/tags/v')
        run: |
          if [ -n "${{ env.VERSION }}" ]; then
            echo "Looking for version ${{ env.VERSION }} in CHANGELOG.md"
            
            # Use awk to extract the content for the current version from CHANGELOG.md
            RELEASE_NOTES=$(awk -v version="## [${{ env.VERSION }}]" '
              BEGIN { found=0; }
              $0 ~ version { found=1; next; }
              found && $0 ~ /^## \[/ { found=0; }
              found { print $0; }
            ' CHANGELOG.md)
            
            # Create a temporary file for the release notes
            echo "$RELEASE_NOTES" > release_notes.md
            echo "Release notes extracted to release_notes.md"
            
            # Show the content for debugging
            echo "===== BEGIN RELEASE NOTES ====="
            cat release_notes.md
            echo "===== END RELEASE NOTES ====="
          else
            echo "No version found, using default release notes"
            echo "Latest build from branch ${GITHUB_REF#refs/heads/}" > release_notes.md
          fi

          # Make sure the file is not empty
          if [ ! -s release_notes.md ]; then
            echo "Warning: release_notes.md is empty! Adding default content."
            echo "Release ${{ env.TAG || github.ref_name }}" > release_notes.md
          fi

      - name: Generate release notes manually if not found
        if: startsWith(github.ref, 'refs/tags/v')
        run: |
          # Explicitly check if release notes content was found
          if ! grep -q "[A-Za-z]" release_notes.md; then
            echo "No specific release notes found for version ${{ env.VERSION }}."
            echo "Creating manual release notes."
            echo "### Release ${{ env.TAG }}" > release_notes.md
            echo "" >> release_notes.md
            echo "This release includes various improvements and bug fixes." >> release_notes.md
            echo "" >> release_notes.md
            echo "For detailed information, please check the [CHANGELOG.md](https://github.com/${{ github.repository }}/blob/main/CHANGELOG.md) file." >> release_notes.md
          fi

      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          path: dist

      - name: Display artifacts
        run: ls -R dist

      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          name: "Release ${{ env.TAG || github.ref_name }}"
          tag_name: "${{ env.TAG || github.ref_name }}"
          body_path: release_notes.md
          files: |
            dist/**/*.exe
            dist/**/*.dmg
            dist/**/*.zip
          draft: false
          prerelease: ${{ !startsWith(github.ref, 'refs/tags/v') }}
          fail_on_unmatched_files: false
        env:
          GITHUB_TOKEN: ${{ secrets.PACKAGES }}

      # Discord notification
      - name: Send Discord Notification
        if: success()
        run: |
          # Get short SHA
          SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)
          COMMIT_URL="https://github.com/${{ github.repository }}/commit/${{ github.sha }}"

          # Determine release info
          if [[ "$GITHUB_REF" == refs/tags/* ]]; then
            RELEASE_TAG="${GITHUB_REF#refs/tags/}"
            RELEASE_NAME="$RELEASE_TAG"
            BRANCH_COLOR="2201331"  # Blue for tags
          else
            RELEASE_TAG="latest"
            RELEASE_NAME="Latest Build"
            BRANCH_COLOR="4885929"  # Green for main
          fi

          RELEASE_URL="https://github.com/${{ github.repository }}/releases/tag/$RELEASE_TAG"

          # Create Discord payload
          cat > discord-payload.json << EOF
          {
            "embeds": [{
              "title": "🚀 New Release: StreamNet Rebrands Panels",
              "color": $BRANCH_COLOR,
              "description": "A new version has been built and released!",
              "fields": [
                {
                  "name": "🏷️ Version",
                  "value": "$RELEASE_NAME",
                  "inline": true
                },
                {
                  "name": "🧠 Commit",
                  "value": "[\`$SHORT_SHA\`]($COMMIT_URL)",
                  "inline": true
                },
                {
                  "name": "📦 Download",
                  "value": "[Release Page]($RELEASE_URL)",
                  "inline": false
                },
                {
                  "name": "💻 Platforms",
                  "value": "Windows, macOS",
                  "inline": false
                }
              ],
              "thumbnail": {
                "url": "https://github.com/cyb3rgh05t/rebrand-tool/blob/main/assets/icons/png/256x256.png?raw=true"
              },
              "footer": {
                "text": "StreamNet Rebrands Panels",
                "icon_url": "https://github.com/${{ github.repository_owner }}.png"
              },
              "timestamp": "$(date -u +'%Y-%m-%dT%H:%M:%SZ')"
            }]
          }
          EOF

          # Send the webhook if DISCORD_WEBHOOK exists
          if [ -n "${{ secrets.DISCORD_WEBHOOK }}" ]; then
            curl -X POST ${{ secrets.DISCORD_WEBHOOK }} \
              -H "Content-Type: application/json" \
              -d @discord-payload.json
          fi
        shell: bash
